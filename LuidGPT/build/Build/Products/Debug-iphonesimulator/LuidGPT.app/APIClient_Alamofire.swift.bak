//
//  APIClient.swift
//  LuidGPT
//
//  Core HTTP client with Alamofire
//  Handles authentication, token injection, and error handling
//

import Foundation
import Alamofire

/// API Error types
enum APIError: Error {
    case invalidURL
    case noData
    case decodingError(Error)
    case serverError(String)
    case unauthorized
    case insufficientCredits(required: Int, available: Int)
    case networkError(Error)
    case unknown

    var localizedDescription: String {
        switch self {
        case .invalidURL:
            return "Invalid URL"
        case .noData:
            return "No data received from server"
        case .decodingError(let error):
            return "Failed to decode response: \(error.localizedDescription)"
        case .serverError(let message):
            return message
        case .unauthorized:
            return "Your session has expired. Please login again."
        case .insufficientCredits(let required, let available):
            return "Insufficient credits. Need \(required) but only have \(available)."
        case .networkError(let error):
            return "Network error: \(error.localizedDescription)"
        case .unknown:
            return "An unknown error occurred"
        }
    }
}

/// API Response wrapper
struct APIResponse<T: Codable>: Codable {
    let success: Bool?
    let data: T?
    let error: String?
    let message: String?
}

/// HTTP Methods
enum HTTPMethod: String {
    case get = "GET"
    case post = "POST"
    case put = "PUT"
    case patch = "PATCH"
    case delete = "DELETE"
}

/// API Client - Singleton for making HTTP requests
class APIClient {
    static let shared = APIClient()

    private let session: Session
    private let baseURL: String
    private let keychainManager: KeychainManager

    private init() {
        // Configure Alamofire session
        let configuration = URLSessionConfiguration.default
        configuration.timeoutIntervalForRequest = 30
        configuration.timeoutIntervalForResource = 60

        self.session = Session(configuration: configuration)
        self.baseURL = AppConfig.baseURL
        self.keychainManager = KeychainManager.shared
    }

    // MARK: - Request Methods

    /// Generic GET request
    func get<T: Codable>(
        _ endpoint: String,
        parameters: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T {
        return try await request(
            endpoint: endpoint,
            method: .get,
            parameters: parameters,
            requiresAuth: requiresAuth
        )
    }

    /// Generic POST request
    func post<T: Codable>(
        _ endpoint: String,
        parameters: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T {
        return try await request(
            endpoint: endpoint,
            method: .post,
            parameters: parameters,
            requiresAuth: requiresAuth
        )
    }

    /// Generic PUT request
    func put<T: Codable>(
        _ endpoint: String,
        parameters: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T {
        return try await request(
            endpoint: endpoint,
            method: .put,
            parameters: parameters,
            requiresAuth: requiresAuth
        )
    }

    /// Generic PATCH request
    func patch<T: Codable>(
        _ endpoint: String,
        parameters: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T {
        return try await request(
            endpoint: endpoint,
            method: .patch,
            parameters: parameters,
            requiresAuth: requiresAuth
        )
    }

    /// Generic DELETE request
    func delete<T: Codable>(
        _ endpoint: String,
        parameters: [String: Any]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T {
        return try await request(
            endpoint: endpoint,
            method: .delete,
            parameters: parameters,
            requiresAuth: requiresAuth
        )
    }

    // MARK: - Core Request Method

    private func request<T: Codable>(
        endpoint: String,
        method: HTTPMethod,
        parameters: [String: Any]? = nil,
        requiresAuth: Bool
    ) async throws -> T {
        // Build URL
        guard let url = URL(string: baseURL + endpoint) else {
            throw APIError.invalidURL
        }

        // Build headers
        var headers = HTTPHeaders([
            "Content-Type": "application/json",
            "Accept": "application/json"
        ])

        // Add auth token if required
        if requiresAuth {
            guard let token = keychainManager.getAccessToken() else {
                throw APIError.unauthorized
            }
            headers.add(name: "Authorization", value: "Bearer \(token)")
        }

        // Convert method
        let alamofireMethod: Alamofire.HTTPMethod = {
            switch method {
            case .get: return .get
            case .post: return .post
            case .put: return .put
            case .patch: return .patch
            case .delete: return .delete
            }
        }()

        // Make request
        return try await withCheckedThrowingContinuation { continuation in
            session.request(
                url,
                method: alamofireMethod,
                parameters: parameters,
                encoding: method == .get ? URLEncoding.default : JSONEncoding.default,
                headers: headers
            )
            .validate()
            .responseDecodable(of: T.self) { response in
                switch response.result {
                case .success(let value):
                    continuation.resume(returning: value)

                case .failure(let error):
                    // Handle specific error cases
                    if let statusCode = response.response?.statusCode {
                        switch statusCode {
                        case 401:
                            // Token expired - clear keychain
                            self.keychainManager.clearTokens()
                            continuation.resume(throwing: APIError.unauthorized)

                        case 402:
                            // Insufficient credits
                            if let data = response.data,
                               let errorResponse = try? JSONDecoder().decode(CreditErrorResponse.self, from: data) {
                                continuation.resume(throwing: APIError.insufficientCredits(
                                    required: errorResponse.details?.required ?? 0,
                                    available: errorResponse.details?.available ?? 0
                                ))
                            } else {
                                continuation.resume(throwing: APIError.serverError("Insufficient credits"))
                            }

                        case 400...499:
                            // Client error
                            if let data = response.data,
                               let errorResponse = try? JSONDecoder().decode(ErrorResponse.self, from: data) {
                                continuation.resume(throwing: APIError.serverError(
                                    errorResponse.error ?? errorResponse.message ?? "Request failed"
                                ))
                            } else {
                                continuation.resume(throwing: APIError.serverError("Request failed"))
                            }

                        case 500...599:
                            // Server error
                            continuation.resume(throwing: APIError.serverError("Server error occurred"))

                        default:
                            continuation.resume(throwing: APIError.networkError(error))
                        }
                    } else {
                        // Network error (no response)
                        continuation.resume(throwing: APIError.networkError(error))
                    }
                }
            }
        }
    }

    // MARK: - File Upload

    /// Upload file with multipart form data
    func uploadFile<T: Codable>(
        _ endpoint: String,
        fileData: Data,
        fileName: String,
        mimeType: String,
        parameters: [String: String]? = nil,
        requiresAuth: Bool = true
    ) async throws -> T {
        guard let url = URL(string: baseURL + endpoint) else {
            throw APIError.invalidURL
        }

        var headers = HTTPHeaders()
        if requiresAuth {
            guard let token = keychainManager.getAccessToken() else {
                throw APIError.unauthorized
            }
            headers.add(name: "Authorization", value: "Bearer \(token)")
        }

        return try await withCheckedThrowingContinuation { continuation in
            session.upload(
                multipartFormData: { multipartFormData in
                    // Add file
                    multipartFormData.append(
                        fileData,
                        withName: "file",
                        fileName: fileName,
                        mimeType: mimeType
                    )

                    // Add other parameters
                    parameters?.forEach { key, value in
                        if let data = value.data(using: .utf8) {
                            multipartFormData.append(data, withName: key)
                        }
                    }
                },
                to: url,
                headers: headers
            )
            .validate()
            .responseDecodable(of: T.self) { response in
                switch response.result {
                case .success(let value):
                    continuation.resume(returning: value)
                case .failure(let error):
                    continuation.resume(throwing: APIError.networkError(error))
                }
            }
        }
    }
}

// MARK: - Error Response Models

struct ErrorResponse: Codable {
    let error: String?
    let message: String?
    let code: String?
}

struct CreditErrorResponse: Codable {
    let error: String?
    let message: String?
    let code: String?
    let details: CreditErrorDetails?
}

struct CreditErrorDetails: Codable {
    let required: Int
    let available: Int
    let deficit: Int
}
